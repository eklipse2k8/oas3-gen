use std::{
  collections::{BTreeMap, HashMap},
  rc::Rc,
};

use clap::ValueEnum;
use proc_macro2::TokenStream;
use quote::{ToTokens, quote};

use self::{client::ClientGenerator, mod_file::ModFileGenerator, server::ServerGenerator};
use super::ast::{
  ClientRootNode, GlobalLintsNode, MethodKind, OperationInfo, RegexKey, RustType, SerdeImpl, ValidationAttribute,
  tokens::ConstToken,
};
use crate::generator::{
  ast::{Documentation, FileHeaderNode, constants::HttpHeaderRef},
  converter::CodegenConfig,
};

pub mod attributes;
pub mod client;
pub mod coercion;
pub mod constants;
pub mod enums;
pub(crate) mod headers;
pub mod http;
pub mod methods;
pub mod mod_file;
pub mod server;
pub mod structs;
pub mod type_aliases;

#[cfg(test)]
mod tests;

#[derive(ValueEnum, Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Visibility {
  #[default]
  Public,
  Crate,
  File,
}

impl ToTokens for Visibility {
  fn to_tokens(&self, tokens: &mut TokenStream) {
    let ts = match self {
      Visibility::Public => quote! { pub },
      Visibility::Crate => quote! { pub(crate) },
      Visibility::File => quote! {},
    };
    tokens.extend(ts);
  }
}

impl Visibility {
  pub(crate) fn to_tokens(self) -> TokenStream {
    match self {
      Visibility::Public => quote! { pub },
      Visibility::Crate => quote! { pub(crate) },
      Visibility::File => quote! {},
    }
  }
}

#[derive(Debug, Clone, Default)]
pub(crate) struct CodeGenerationContext {
  pub(crate) config: CodegenConfig,
}

impl CodeGenerationContext {
  pub(crate) fn new(config: CodegenConfig) -> Self {
    Self { config }
  }
}

pub fn format(code: &TokenStream) -> anyhow::Result<String> {
  let syntax_tree = syn::parse2(code.clone())?;
  Ok(prettyplease::unparse(&syntax_tree))
}

impl ToTokens for FileHeaderNode {
  fn to_tokens(&self, tokens: &mut TokenStream) {
    self.lints.to_tokens(tokens);

    let title_line = format!(" {}", self.title);
    let source_line = format!(" Source: {}", self.source_path);
    let version_line = format!(" Version: {}", self.version);
    let generator_line = format!(" Generated by `oas3-gen v{}`", self.generator_version);

    let header = quote! {
      #![doc = ""]
      #![doc = " AUTO-GENERATED CODE - DO NOT EDIT!"]
      #![doc = ""]
      #![doc = #title_line]
      #![doc = #source_line]
      #![doc = #version_line]
      #![doc = #generator_line]
      #![doc = ""]
    };

    tokens.extend(header);

    let description_text = self.description.clone().map(|d| d.with_top_level(true));

    if let Some(description_text) = description_text {
      tokens.extend(description_text.to_token_stream());
    }
  }
}

fn generate_source(
  code: &TokenStream,
  metadata: &ClientRootNode,
  lint_config: Option<&GlobalLintsNode>,
  source_path: &str,
  gen_version: &str,
) -> anyhow::Result<String> {
  let lints = lint_config.map_or_else(|| GlobalLintsNode::builder().build(), std::clone::Clone::clone);
  let header_node = FileHeaderNode::builder()
    .title(metadata.title.clone())
    .version(metadata.version.clone())
    .source_path(source_path.to_string())
    .generator_version(gen_version.to_string())
    .description(Documentation::from_optional(metadata.description.as_ref()))
    .lints(lints)
    .build();

  let header_formatted = format(&header_node.to_token_stream())?;
  let code_formatted = format(code)?;
  Ok(format!("{header_formatted}\n{code_formatted}\n"))
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GeneratedFileType {
  Client,
  Module,
  Server,
  Types,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct GeneratedResult {
  pub code: HashMap<GeneratedFileType, String>,
}

impl GeneratedResult {
  pub fn client(code: String) -> Self {
    Self {
      code: HashMap::from([(GeneratedFileType::Client, code)]),
    }
  }

  pub fn types(code: String) -> Self {
    Self {
      code: HashMap::from([(GeneratedFileType::Types, code)]),
    }
  }

  pub fn full_client(mod_file: String, client: String, types: String) -> Self {
    Self {
      code: HashMap::from([
        (GeneratedFileType::Module, mod_file),
        (GeneratedFileType::Client, client),
        (GeneratedFileType::Types, types),
      ]),
    }
  }

  pub fn full_server(mod_file: String, server: String, types: String) -> Self {
    Self {
      code: HashMap::from([
        (GeneratedFileType::Module, mod_file),
        (GeneratedFileType::Server, server),
        (GeneratedFileType::Types, types),
      ]),
    }
  }

  pub fn code(&self, file_type: &GeneratedFileType) -> Option<&String> {
    self.code.get(file_type)
  }
}

#[derive(Debug, Clone)]
pub struct SchemaCodeGenerator {
  context: Rc<CodeGenerationContext>,
  rust_types: Rc<Vec<RustType>>,
  operations: Rc<Vec<OperationInfo>>,
  header_refs: Rc<Vec<HttpHeaderRef>>,
  client: Rc<ClientRootNode>,
  visibility: Visibility,
  source_path: String,
  gen_version: String,
}

#[bon::bon]
impl SchemaCodeGenerator {
  #[builder]
  pub fn new(
    config: CodegenConfig,
    rust_types: Vec<RustType>,
    operations: Vec<OperationInfo>,
    header_refs: Vec<HttpHeaderRef>,
    client: ClientRootNode,
    visibility: Visibility,
    source_path: String,
    gen_version: String,
  ) -> Self {
    Self {
      context: Rc::new(CodeGenerationContext::new(config)),
      rust_types: Rc::new(rust_types),
      operations: Rc::new(operations),
      header_refs: Rc::new(header_refs),
      client: Rc::new(client),
      visibility,
      source_path,
      gen_version,
    }
  }
}

impl SchemaCodeGenerator {
  pub fn generate_types(&self) -> anyhow::Result<GeneratedResult> {
    let lint_config = GlobalLintsNode::default();
    let code_tokens = self.generate_types_tokens();
    let code = self.generate_file_with_lint(&code_tokens, &lint_config)?;
    Ok(GeneratedResult::types(code))
  }

  pub fn generate_client(&self) -> anyhow::Result<GeneratedResult> {
    let client_generator = ClientGenerator::new(&self.client, &self.operations, self.visibility);
    let client_tokens = client_generator.into_token_stream();
    let lint_config = GlobalLintsNode::default();

    let code = generate_source(
      &client_tokens,
      &self.client,
      Some(&lint_config),
      &self.source_path,
      &self.gen_version,
    )?;

    Ok(GeneratedResult::client(code))
  }

  pub fn generate_client_mod(&self) -> anyhow::Result<GeneratedResult> {
    let types_tokens = self.generate_types_tokens();
    let types_code = generate_source(&types_tokens, &self.client, None, &self.source_path, &self.gen_version)?;

    let client_generator = ClientGenerator::new(&self.client, &self.operations, self.visibility).with_types_import();
    let client_tokens = client_generator.into_token_stream();
    let client_code = generate_source(&client_tokens, &self.client, None, &self.source_path, &self.gen_version)?;

    let mod_generator = ModFileGenerator::new(&self.client, self.visibility);
    let mod_code = mod_generator.generate(&self.source_path, &self.gen_version)?;

    Ok(GeneratedResult::full_client(mod_code, client_code, types_code))
  }

  pub fn generate_server_mod(&self) -> anyhow::Result<GeneratedResult> {
    let types_tokens = self.generate_types_tokens();
    let types_code = generate_source(&types_tokens, &self.client, None, &self.source_path, &self.gen_version)?;

    let server_generator = ServerGenerator::new(&self.client, &self.operations, self.visibility).with_types_import();
    let server_tokens = server_generator.into_token_stream();
    let server_code = generate_source(&server_tokens, &self.client, None, &self.source_path, &self.gen_version)?;

    let mod_generator = ModFileGenerator::for_server(&self.client, self.visibility);
    let mod_code = mod_generator.generate(&self.source_path, &self.gen_version)?;

    Ok(GeneratedResult::full_server(mod_code, server_code, types_code))
  }

  fn generate_file_with_lint(
    &self,
    code_tokens: &TokenStream,
    lint_config: &GlobalLintsNode,
  ) -> anyhow::Result<String> {
    generate_source(
      code_tokens,
      &self.client,
      Some(lint_config),
      &self.source_path,
      &self.gen_version,
    )
  }

  fn generate_types_tokens(&self) -> TokenStream {
    let (regex_consts, regex_lookup) = constants::generate_regex_constants(&self.rust_types);
    let header_consts = constants::generate_header_constants(&self.header_refs);

    let mut needs_serialize = false;
    let mut needs_deserialize = false;
    let mut needs_validate = false;
    let mut type_tokens = vec![];

    for ty in self.rust_types.iter() {
      needs_serialize |= ty.is_serializable() == SerdeImpl::Derive;
      needs_deserialize |= ty.is_deserializable() == SerdeImpl::Derive;
      needs_validate |= matches!(ty, RustType::Struct(def) if def.fields.iter().any(|f| f.validation_attrs.contains(&ValidationAttribute::Nested)));
      needs_validate |=
        matches!(ty, RustType::Struct(def) if def.methods.iter().any(|m| matches!(m.kind, MethodKind::Builder { .. })));
      type_tokens.push(self.generate_type(ty, &regex_lookup));
    }

    let serde_use = match (needs_serialize, needs_deserialize) {
      (true, true) => quote! { use serde::{Deserialize, Serialize}; },
      (true, false) => quote! { use serde::Serialize; },
      (false, true) => quote! { use serde::Deserialize; },
      (false, false) => quote! {},
    };

    let validator_use = if needs_validate {
      quote! { use validator::Validate; }
    } else {
      quote! {}
    };

    quote! {
      #serde_use
      #validator_use

      #regex_consts
      #header_consts

      #(#type_tokens)*
    }
  }

  fn generate_type(&self, rust_type: &RustType, regex_lookup: &BTreeMap<RegexKey, ConstToken>) -> TokenStream {
    match rust_type {
      RustType::Struct(def) => structs::StructGenerator::new(&self.context, def, regex_lookup, self.visibility).emit(),
      RustType::Enum(def) => enums::EnumGenerator::new(&self.context, def, self.visibility).generate(),
      RustType::TypeAlias(def) => {
        type_aliases::TypeAliasFragment::new(def.clone(), self.visibility).into_token_stream()
      }
      RustType::DiscriminatedEnum(def) => {
        enums::DiscriminatedEnumGenerator::new(&self.context, def, self.visibility).generate()
      }
      RustType::ResponseEnum(def) => enums::ResponseEnumGenerator::new(&self.context, def, self.visibility).generate(),
    }
  }
}
