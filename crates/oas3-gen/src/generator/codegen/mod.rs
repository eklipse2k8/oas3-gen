use std::collections::{BTreeMap, BTreeSet};

use anyhow::Context as _;
use clap::ValueEnum;
use proc_macro2::TokenStream;
use quote::{ToTokens, quote};

use super::ast::{
  ClientDef, LintConfig, RegexKey, RustType, SerdeImpl, StructKind, StructMethodKind, ValidationAttribute,
  tokens::{ConstToken, HeaderToken},
};

pub mod attributes;
pub mod client;
pub mod coercion;
pub mod constants;
pub mod enums;
pub mod mod_file;
pub mod structs;
pub mod type_aliases;

#[cfg(test)]
mod tests;

#[derive(ValueEnum, Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Visibility {
  #[default]
  Public,
  Crate,
  File,
}

impl Visibility {
  pub(crate) fn to_tokens(self) -> TokenStream {
    match self {
      Visibility::Public => quote! { pub },
      Visibility::Crate => quote! { pub(crate) },
      Visibility::File => quote! {},
    }
  }
}

pub fn format(code: &TokenStream) -> anyhow::Result<String> {
  let syntax_tree = syn::parse2(code.clone())?;
  Ok(prettyplease::unparse(&syntax_tree))
}

pub fn generate_file(
  types: &[RustType],
  visibility: Visibility,
  metadata: &ClientDef,
  lint_config: &LintConfig,
  source_path: &str,
  gen_version: &str,
) -> anyhow::Result<String> {
  let code_tokens = generate(types, visibility);
  generate_source(&code_tokens, metadata, Some(lint_config), source_path, gen_version)
}

pub fn generate_source(
  code: &TokenStream,
  metadata: &ClientDef,
  lint_config: Option<&LintConfig>,
  source_path: &str,
  gen_version: &str,
) -> anyhow::Result<String> {
  let formatted_code = format(code)?;

  let description = metadata.description.as_ref().map_or_else(
    || String::from("No description provided"),
    |d| d.replace('\n', "\n//! "),
  );

  let lint_directives = lint_config.map_or_else(String::new, |cfg| {
    format(&cfg.to_token_stream()).unwrap_or_default() + "\n"
  });

  let header = format!(
    r"{lint_directives}//!
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! {}
//! Source: {}
//! Version: {}
//! Generated by `oas3-gen v{}`
//!
//! {}",
    metadata.title, source_path, metadata.version, gen_version, description
  );

  Ok(format!("{header}\n\n{formatted_code}\n"))
}

pub(crate) fn generate(types: &[RustType], visibility: Visibility) -> TokenStream {
  let ordered = deduplicate_and_order_types(types);
  let (regex_consts, regex_lookup) = constants::generate_regex_constants(&ordered);
  let header_consts = constants::generate_header_constants(&collect_header_tokens(&ordered));

  let mut needs_serialize = false;
  let mut needs_deserialize = false;
  let mut needs_validate = false;
  let mut type_tokens = vec![];

  for ty in &ordered {
    needs_serialize |= ty.is_serializable() == SerdeImpl::Derive;
    needs_deserialize |= ty.is_deserializable() == SerdeImpl::Derive;
    needs_validate |= matches!(ty, RustType::Struct(def) if def.fields.iter().any(|f| f.validation_attrs.contains(&ValidationAttribute::Nested)));
    needs_validate |= matches!(ty, RustType::Struct(def) if def.methods.iter().any(|m| matches!(m.kind, StructMethodKind::Builder { .. })));
    type_tokens.push(generate_type(ty, &regex_lookup, visibility));
  }

  // TODO: Create a more general way to track imports needed by types
  let serde_use = match (needs_serialize, needs_deserialize) {
    (true, true) => quote! { use serde::{Deserialize, Serialize}; },
    (true, false) => quote! { use serde::Serialize; },
    (false, true) => quote! { use serde::Deserialize; },
    (false, false) => quote! {},
  };

  let validator_use = if needs_validate {
    quote! { use validator::Validate; }
  } else {
    quote! {}
  };

  quote! {
    #serde_use
    #validator_use

    #regex_consts
    #header_consts

    #(#type_tokens)*
  }
}

fn deduplicate_and_order_types<'a>(types: &'a [RustType]) -> Vec<&'a RustType> {
  let mut map: BTreeMap<String, &'a RustType> = BTreeMap::new();
  for ty in types {
    let name = ty.type_name().to_string();

    if let Some(existing) = map.get(&name) {
      let existing_priority = type_priority(existing);
      let new_priority = type_priority(ty);

      if new_priority < existing_priority {
        map.insert(name, ty);
      }
    } else {
      map.insert(name, ty);
    }
  }
  map.into_values().collect()
}

fn collect_header_tokens(types: &[&RustType]) -> Vec<HeaderToken> {
  let mut seen: BTreeSet<String> = BTreeSet::new();
  let mut headers = Vec::new();

  for rust_type in types {
    let RustType::Struct(def) = rust_type else {
      continue;
    };

    if !matches!(def.kind, StructKind::HeaderParams) {
      continue;
    }

    for field in &def.fields {
      if let Some(original_name) = &field.original_name
        && seen.insert(original_name.clone())
      {
        headers.push(HeaderToken::from(original_name.as_str()));
      }
    }
  }

  headers
}

fn type_priority(rust_type: &RustType) -> u8 {
  match rust_type {
    RustType::Struct(_) => 0,
    RustType::ResponseEnum(_) => 1,
    RustType::DiscriminatedEnum(_) => 2,
    RustType::Enum(_) => 3,
    RustType::TypeAlias(_) => 4,
  }
}

fn generate_type(
  rust_type: &RustType,
  regex_lookup: &BTreeMap<RegexKey, ConstToken>,
  visibility: Visibility,
) -> TokenStream {
  match rust_type {
    RustType::Struct(def) => structs::StructGenerator::new(def, regex_lookup, visibility).emit(),
    RustType::Enum(def) => enums::EnumGenerator::new(def, visibility).generate(),
    RustType::TypeAlias(def) => type_aliases::generate_type_alias(def, visibility),
    RustType::DiscriminatedEnum(def) => enums::DiscriminatedEnumGenerator::new(def, visibility).generate(),
    RustType::ResponseEnum(def) => enums::ResponseEnumGenerator::new(def, visibility).generate(),
  }
}

pub(crate) fn parse_type(type_name: &str) -> anyhow::Result<syn::Type> {
  syn::parse_str(type_name).context("failed to parse type `{type_name}`")
}
