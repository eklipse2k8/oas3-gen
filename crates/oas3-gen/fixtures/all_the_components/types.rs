#![allow(clippy::doc_markdown)]
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::missing_panics_doc)]
#![allow(clippy::result_large_err)]
#![allow(clippy::struct_field_names)]
#![allow(clippy::unnecessary_wraps)]
#![allow(clippy::unused_self)]
//!
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! Burger Shop
//! Source: crates/oas3-gen/fixtures/all-the-components.json
//! Version: 1.2
//! Generated by `oas3-gen v0.22.0`
//!
//! The best burger API at quobix. You can find the testiest burgers on the world
//!

use serde::{Deserialize, Serialize};
///The tastiest food on the planet you would love to eat everyday
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct Burger {
  ///Unique burger identifier
  pub id: Option<String>,
  ///The name of your tasty burger - burger names are listed in our menus
  #[validate(length(min = 1u64))]
  pub name: String,
  ///The number of burger patties used
  #[serde(rename = "numPatties")]
  pub num_patties: i64,
  ///how many slices of orange goodness would you like?
  #[serde(rename = "numTomatoes")]
  pub num_tomatoes: Option<i64>,
}
///A new burger for our menu, yummy yum yum.
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct CreateBurgerRequest {
  ///Give us the new burger!
  pub body: Option<CreateBurgerRequestBody>,
}
impl CreateBurgerRequest {
  ///Render the request path with parameters.
  pub fn render_path(&self) -> anyhow::Result<String> {
    Ok("burgers".to_string())
  }
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(self, response: reqwest::Response) -> anyhow::Result<CreateBurgerResponse> {
    let status = response.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<Burger>::json_with_diagnostics(response).await?;
      let links = CreateBurgerResponseOkLinks {
        another_locate_burger: data.id.as_ref().map(|_| LocateBurgerRequest {
          burger_id: data.id.clone().unwrap_or_default(),
        }),
        locate_burger: data.id.as_ref().map(|_| LocateBurgerRequest {
          burger_id: data.id.clone().unwrap_or_default(),
        }),
      };
      return Ok(CreateBurgerResponse::Ok(data, links));
    }
    if status.as_u16() == 422u16 {
      let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(response).await?;
      return Ok(CreateBurgerResponse::UnprocessableEntity(data));
    }
    if status.as_u16() == 500u16 {
      let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(response).await?;
      return Ok(CreateBurgerResponse::InternalServerError(data));
    }
    let _ = response.bytes().await?;
    Ok(CreateBurgerResponse::Unknown)
  }
}
///Give us the new burger!
pub type CreateBurgerRequestBody = Burger;
///Response types for createBurger
#[derive(Debug, Clone)]
pub enum CreateBurgerResponse {
  ///200: A tasty burger for you to eat.
  Ok(Burger, CreateBurgerResponseOkLinks),
  ///422: Unprocessable entity
  UnprocessableEntity(Error),
  ///500: Unexpected error creating a new burger. Sorry.
  InternalServerError(Error),
  ///default: Unknown response
  Unknown,
}
#[derive(Debug, Clone, Default)]
pub struct CreateBurgerResponseOkLinks {
  ///Go and get a another really tasty burger
  pub another_locate_burger: Option<LocateBurgerRequest>,
  ///Go and get a tasty burger
  pub locate_burger: Option<LocateBurgerRequest>,
}
impl CreateBurgerResponse {
  pub fn body(&self) -> Option<&Burger> {
    match self {
      Self::Ok(body, _) => Some(body),
      _ => None,
    }
  }
  pub fn into_body(self) -> Option<Burger> {
    match self {
      Self::Ok(body, _) => Some(body),
      _ => None,
    }
  }
  pub fn to_another_locate_burger(&self) -> Option<LocateBurgerRequest> {
    match self {
      Self::Ok(_, links) => links.another_locate_burger.clone(),
      _ => None,
    }
  }
  pub fn to_locate_burger(&self) -> Option<LocateBurgerRequest> {
    match self {
      Self::Ok(_, links) => links.locate_burger.clone(),
      _ => None,
    }
  }
}
impl TryFrom<CreateBurgerResponse> for Burger {
  type Error = CreateBurgerResponse;
  fn try_from(response: CreateBurgerResponse) -> Result<Self, Self::Error> {
    match response {
      CreateBurgerResponse::Ok(body, _) => Ok(body),
      other => Err(other),
    }
  }
}
impl TryFrom<CreateBurgerResponse> for LocateBurgerRequest {
  type Error = CreateBurgerResponse;
  fn try_from(response: CreateBurgerResponse) -> Result<Self, Self::Error> {
    match response {
      CreateBurgerResponse::Ok(_, links) => links.another_locate_burger.ok_or(CreateBurgerResponse::Unknown),
      other => Err(other),
    }
  }
}
///This is the object that contains the information about the content of the dressing
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct Dressing {
  ///The name of your dressing you can pick up from the menu
  #[validate(length(min = 1u64))]
  pub name: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Dressing200Response {}
///a frosty cold beverage can be coke or sprite
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct Drink {
  ///select from coke or sprite
  #[serde(rename = "drinkType")]
  pub drink_type: DrinkDrinkType,
  pub ice: Option<bool>,
  ///what size man? S/M/L
  #[validate(length(min = 1u64))]
  pub size: String,
}
///select from coke or sprite
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum DrinkDrinkType {
  #[serde(rename = "coke")]
  #[default]
  Coke,
  #[serde(rename = "sprite")]
  Sprite,
}
///Error defining what went wrong when providing a specification. The message should help indicate the issue clearly.
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Error {
  ///returns the error message if something wrong happens
  pub message: Option<String>,
}
impl std::fmt::Display for Error {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    if let Some(ref msg) = self.message {
      write!(f, "{msg}")
    } else {
      write!(f, "Error")
    }
  }
}
impl std::error::Error for Error {}
///golden slices of happy fun joy
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct Fries {
  ///The tastiest food on the planet you would love to eat everyday
  #[serde(rename = "favoriteBurger")]
  pub favorite_burger: Option<Burger>,
  #[serde(rename = "favoriteDressings")]
  pub favorite_dressings: Vec<Dressing>,
  ///a frosty cold beverage can be coke or sprite
  #[serde(rename = "favoriteDrink")]
  pub favorite_drink: Drink,
  ///what type of potato shape? wedges? shoestring?
  #[serde(rename = "potatoShape")]
  #[validate(length(min = 1u64))]
  pub potato_shape: String,
  ///herbs and spices for your golden joy
  pub seasoning: Option<Vec<String>>,
}
///Get all dressings and choose from them
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetAllDressingsRequest {}
impl GetAllDressingsRequest {
  ///Render the request path with parameters.
  pub fn render_path(&self) -> anyhow::Result<String> {
    Ok("dressings".to_string())
  }
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(self, response: reqwest::Response) -> anyhow::Result<GetAllDressingsResponse> {
    let status = response.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<Dressing200Response>::json_with_diagnostics(response).await?;
      return Ok(GetAllDressingsResponse::Ok(data));
    }
    if status.as_u16() == 500u16 {
      let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(response).await?;
      return Ok(GetAllDressingsResponse::InternalServerError(data));
    }
    let _ = response.bytes().await?;
    Ok(GetAllDressingsResponse::Unknown)
  }
}
///Response types for getAllDressings
#[derive(Debug, Clone)]
pub enum GetAllDressingsResponse {
  ///200: an array of dressings
  Ok(Dressing200Response),
  ///500: Unexpected error. Sorry.
  InternalServerError(Error),
  ///default: Unknown response
  Unknown,
}
///Same as the summary, get a dressing, by its ID
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetDressingRequest {
  ///This is the unique identifier for the dressing items.
  ///- Location: `Path`
  ///- Example: `"cheese".to_string()`
  #[validate(length(min = 1u64))]
  pub dressing_id: String,
}
impl GetDressingRequest {
  ///Render the request path with parameters.
  pub fn render_path(&self) -> anyhow::Result<String> {
    Ok(format!(
      "dressings/{}",
      oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.dressing_id)?)
    ))
  }
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(self, response: reqwest::Response) -> anyhow::Result<GetDressingResponse> {
    let status = response.status();
    if status.as_u16() == 404u16 {
      let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(response).await?;
      return Ok(GetDressingResponse::NotFound(data));
    }
    if status.as_u16() == 500u16 {
      let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(response).await?;
      return Ok(GetDressingResponse::InternalServerError(data));
    }
    let _ = response.bytes().await?;
    Ok(GetDressingResponse::Unknown)
  }
}
///Response types for getDressing
#[derive(Debug, Clone)]
pub enum GetDressingResponse {
  ///404: Cannot find your dressing, sorry.
  NotFound(Error),
  ///500: Unexpected error getting a dressing. Sorry.
  InternalServerError(Error),
  ///default: Unknown response
  Unknown,
}
///Same as the summary, look up a tasty burger, by its ID - the burger identifier
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ListBurgerDressingsRequest {
  ///the name of the our fantastic burger. You can pick a name from our menu
  ///- Location: `Path`
  ///- Example: `"big-mac".to_string()`
  #[validate(length(min = 1u64))]
  pub burger_id: String,
}
impl ListBurgerDressingsRequest {
  ///Render the request path with parameters.
  pub fn render_path(&self) -> anyhow::Result<String> {
    Ok(format!(
      "burgers/{}/dressings",
      oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.burger_id)?)
    ))
  }
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(self, response: reqwest::Response) -> anyhow::Result<ListBurgerDressingsResponse> {
    let status = response.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<Dressing200Response>::json_with_diagnostics(response).await?;
      let links = ListBurgerDressingsResponseOkLinks { get_burger: None };
      return Ok(ListBurgerDressingsResponse::Ok(data, links));
    }
    if status.as_u16() == 404u16 {
      let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(response).await?;
      return Ok(ListBurgerDressingsResponse::NotFound(data));
    }
    if status.as_u16() == 500u16 {
      let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(response).await?;
      return Ok(ListBurgerDressingsResponse::InternalServerError(data));
    }
    let _ = response.bytes().await?;
    Ok(ListBurgerDressingsResponse::Unknown)
  }
}
///Response types for listBurgerDressings
#[derive(Debug, Clone)]
pub enum ListBurgerDressingsResponse {
  ///200: an array of
  Ok(Dressing200Response, ListBurgerDressingsResponseOkLinks),
  ///404: Cannot find your burger in which to list dressings. Sorry
  NotFound(Error),
  ///500: Unexpected error listing dressings for burger. Sorry.
  InternalServerError(Error),
  ///default: Unknown response
  Unknown,
}
#[derive(Debug, Clone, Default)]
pub struct ListBurgerDressingsResponseOkLinks {
  ///Get the burger details
  pub get_burger: Option<LocateBurgerRequest>,
}
impl ListBurgerDressingsResponse {
  pub fn body(&self) -> Option<&Dressing200Response> {
    match self {
      Self::Ok(body, _) => Some(body),
      _ => None,
    }
  }
  pub fn into_body(self) -> Option<Dressing200Response> {
    match self {
      Self::Ok(body, _) => Some(body),
      _ => None,
    }
  }
  pub fn to_get_burger(&self) -> Option<LocateBurgerRequest> {
    match self {
      Self::Ok(_, links) => links.get_burger.clone(),
      _ => None,
    }
  }
}
impl TryFrom<ListBurgerDressingsResponse> for Dressing200Response {
  type Error = ListBurgerDressingsResponse;
  fn try_from(response: ListBurgerDressingsResponse) -> Result<Self, Self::Error> {
    match response {
      ListBurgerDressingsResponse::Ok(body, _) => Ok(body),
      other => Err(other),
    }
  }
}
impl TryFrom<ListBurgerDressingsResponse> for LocateBurgerRequest {
  type Error = ListBurgerDressingsResponse;
  fn try_from(response: ListBurgerDressingsResponse) -> Result<Self, Self::Error> {
    match response {
      ListBurgerDressingsResponse::Ok(_, links) => links.get_burger.ok_or(ListBurgerDressingsResponse::Unknown),
      other => Err(other),
    }
  }
}
///Look up a tasty burger take it and enjoy it
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct LocateBurgerRequest {
  ///the name of the burger. use this to order your food
  ///- Location: `Path`
  ///- Example: `"big-mac".to_string()`
  #[validate(length(min = 1u64))]
  pub burger_id: String,
}
impl LocateBurgerRequest {
  ///Render the request path with parameters.
  pub fn render_path(&self) -> anyhow::Result<String> {
    Ok(format!(
      "burgers/{}",
      oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.burger_id)?)
    ))
  }
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(self, response: reqwest::Response) -> anyhow::Result<LocateBurgerResponse> {
    let status = response.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<Burger>::json_with_diagnostics(response).await?;
      let links = LocateBurgerResponseOkLinks {
        list_burger_dressings: data.id.as_ref().map(|_| ListBurgerDressingsRequest {
          burger_id: data.id.clone().unwrap_or_default(),
        }),
      };
      return Ok(LocateBurgerResponse::Ok(data, links));
    }
    if status.as_u16() == 404u16 {
      let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(response).await?;
      return Ok(LocateBurgerResponse::NotFound(data));
    }
    if status.as_u16() == 500u16 {
      let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(response).await?;
      return Ok(LocateBurgerResponse::InternalServerError(data));
    }
    let _ = response.bytes().await?;
    Ok(LocateBurgerResponse::Unknown)
  }
}
///Response types for locateBurger
#[derive(Debug, Clone)]
pub enum LocateBurgerResponse {
  ///200: A tasty burger for you to eat. Wide variety of products to choose from
  Ok(Burger, LocateBurgerResponseOkLinks),
  ///404: Cannot find your burger. Sorry. We may have sold out of this type
  NotFound(Error),
  ///500: Unexpected error. Sorry.
  InternalServerError(Error),
  ///default: Unknown response
  Unknown,
}
#[derive(Debug, Clone, Default)]
pub struct LocateBurgerResponseOkLinks {
  ///Try the ketchup!
  pub list_burger_dressings: Option<ListBurgerDressingsRequest>,
}
impl LocateBurgerResponse {
  pub fn body(&self) -> Option<&Burger> {
    match self {
      Self::Ok(body, _) => Some(body),
      _ => None,
    }
  }
  pub fn into_body(self) -> Option<Burger> {
    match self {
      Self::Ok(body, _) => Some(body),
      _ => None,
    }
  }
  pub fn to_list_burger_dressings(&self) -> Option<ListBurgerDressingsRequest> {
    match self {
      Self::Ok(_, links) => links.list_burger_dressings.clone(),
      _ => None,
    }
  }
}
impl TryFrom<LocateBurgerResponse> for Burger {
  type Error = LocateBurgerResponse;
  fn try_from(response: LocateBurgerResponse) -> Result<Self, Self::Error> {
    match response {
      LocateBurgerResponse::Ok(body, _) => Ok(body),
      other => Err(other),
    }
  }
}
impl TryFrom<LocateBurgerResponse> for ListBurgerDressingsRequest {
  type Error = LocateBurgerResponse;
  fn try_from(response: LocateBurgerResponse) -> Result<Self, Self::Error> {
    match response {
      LocateBurgerResponse::Ok(_, links) => links.list_burger_dressings.ok_or(LocateBurgerResponse::Unknown),
      other => Err(other),
    }
  }
}
