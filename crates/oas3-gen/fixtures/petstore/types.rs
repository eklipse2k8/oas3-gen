//!
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! Swagger Petstore
//! Source: crates/oas3-gen/fixtures/petstore.json
//! Version: 1.0.0
//! Generated by `oas3-gen v0.23.6`
//!
//! No description provided

use serde::{Deserialize, Serialize};
use validator::Validate;
pub const X_API_VERSION: http::HeaderName = http::HeaderName::from_static("x-api-version");
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Cat {
  #[serde(rename = "favoriteToy")]
  pub favorite_toy: Option<String>,
  pub id: i64,
  pub lives: i32,
  pub name: String,
  pub tag: Option<String>,
}
pub type Cats = Vec<Cat>;
///Create a pet
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct CreatePetsRequest {}
impl CreatePetsRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<CreatePetsResponse> {
    let status = req.status();
    if status.is_success() {
      let _ = req.bytes().await?;
      return Ok(CreatePetsResponse::Created);
    }
    let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(req).await?;
    Ok(CreatePetsResponse::Unknown(data))
  }
}
///Response types for createPets
#[derive(Debug, Clone)]
pub enum CreatePetsResponse {
  ///201: Null response
  Created,
  ///default: unexpected error
  Unknown(Error),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Error {
  pub code: i32,
  pub message: String,
}
///List all cats
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ListCatsRequest {}
impl ListCatsRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<ListCatsResponse> {
    let status = req.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<Cats>::json_with_diagnostics(req).await?;
      return Ok(ListCatsResponse::Ok(data));
    }
    let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(req).await?;
    Ok(ListCatsResponse::Unknown(data))
  }
}
///Response types for listCats
#[derive(Debug, Clone)]
pub enum ListCatsResponse {
  ///200: A paged array of cats
  Ok(Cats),
  ///default: unexpected error
  Unknown(Error),
}
///List all pets
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ListPetsRequest {
  #[validate(nested)]
  pub query: ListPetsRequestQuery,
}
#[bon::bon]
impl ListPetsRequest {
  ///Create a new request with the given parameters.
  #[builder]
  pub fn new(limit: Option<i32>) -> anyhow::Result<Self> {
    let request = Self {
      query: ListPetsRequestQuery { limit },
    };
    request.validate()?;
    Ok(request)
  }
}
impl ListPetsRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<ListPetsResponse> {
    let status = req.status();
    if status.is_success() {
      let content_type_str = req
        .headers()
        .get(reqwest::header::CONTENT_TYPE)
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/json");
      if content_type_str.contains("json") {
        let data = oas3_gen_support::Diagnostics::<Pets>::json_with_diagnostics(req).await?;
        return Ok(ListPetsResponse::Ok(data));
      }
      if content_type_str.contains("xml") {
        let data = oas3_gen_support::Diagnostics::<Pets>::xml_with_diagnostics(req).await?;
        return Ok(ListPetsResponse::Ok(data));
      }
    }
    let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(req).await?;
    Ok(ListPetsResponse::Unknown(data))
  }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct ListPetsRequestQuery {
  ///How many items to return at one time (max 100)
  #[validate(range(min = 1i32, max = 100i32))]
  pub limit: Option<i32>,
}
///Response types for listPets
#[derive(Debug, Clone)]
pub enum ListPetsResponse {
  ///200: A paged array of pets
  Ok(Pets),
  ///default: unexpected error
  Unknown(Error),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Pet {
  pub id: i64,
  pub name: String,
  pub tag: Option<String>,
}
pub type Pets = Vec<Pet>;
///Info for a specific pet
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ShowPetByIdRequest {
  #[validate(nested)]
  pub path: ShowPetByIdRequestPath,
  #[validate(nested)]
  pub header: ShowPetByIdRequestHeader,
}
#[bon::bon]
impl ShowPetByIdRequest {
  ///Create a new request with the given parameters.
  #[builder]
  pub fn new(pet_id: String, x_api_version: String) -> anyhow::Result<Self> {
    let request = Self {
      path: ShowPetByIdRequestPath { pet_id },
      header: ShowPetByIdRequestHeader { x_api_version },
    };
    request.validate()?;
    Ok(request)
  }
}
impl ShowPetByIdRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<ShowPetByIdResponse> {
    let status = req.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<Pet>::json_with_diagnostics(req).await?;
      return Ok(ShowPetByIdResponse::Ok(data));
    }
    let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(req).await?;
    Ok(ShowPetByIdResponse::Unknown(data))
  }
}
#[derive(Debug, Clone, PartialEq, validator::Validate, oas3_gen_support::Default)]
pub struct ShowPetByIdRequestHeader {
  ///API version to use for this request
  #[validate(length(min = 1u64))]
  pub x_api_version: String,
}
impl core::convert::TryFrom<&ShowPetByIdRequestHeader> for http::HeaderMap {
  type Error = http::header::InvalidHeaderValue;
  fn try_from(headers: &ShowPetByIdRequestHeader) -> core::result::Result<Self, Self::Error> {
    let mut map = http::HeaderMap::with_capacity(1usize);
    let header_value = http::HeaderValue::try_from(&headers.x_api_version)?;
    map.insert(X_API_VERSION, header_value);
    Ok(map)
  }
}
impl core::convert::TryFrom<ShowPetByIdRequestHeader> for http::HeaderMap {
  type Error = http::header::InvalidHeaderValue;
  fn try_from(headers: ShowPetByIdRequestHeader) -> core::result::Result<Self, Self::Error> {
    http::HeaderMap::try_from(&headers)
  }
}
#[derive(Debug, Clone, PartialEq, validator::Validate, oas3_gen_support::Default)]
pub struct ShowPetByIdRequestPath {
  ///The id of the pet to retrieve
  #[validate(length(min = 1u64))]
  pub pet_id: String,
}
///Response types for showPetById
#[derive(Debug, Clone)]
pub enum ShowPetByIdResponse {
  ///200: Expected response to a valid request
  Ok(Pet),
  ///default: unexpected error
  Unknown(Error),
}
