//!
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! Swagger Petstore
//! Source: crates/oas3-gen/fixtures/petstore.json
//! Version: 1.0.0
//! Generated by `oas3-gen v0.23.7`
//!
//! No description provided

use serde::{Deserialize, Serialize};
use validator::Validate;
pub const X_API_VERSION: http::HeaderName = http::HeaderName::from_static("x-api-version");
pub const X_ONLY: http::HeaderName = http::HeaderName::from_static("x-only");
pub const X_SORT_ORDER: http::HeaderName = http::HeaderName::from_static("x-sort-order");
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Cat {
  #[serde(rename = "favoriteToy")]
  pub favorite_toy: Option<String>,
  pub id: i64,
  pub lives: i32,
  pub name: String,
  pub tag: Option<String>,
}
pub type Cats = Vec<Cat>;
///Create a pet
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct CreatePetsRequest {}
impl CreatePetsRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<CreatePetsResponse> {
    let status = req.status();
    if status.is_success() {
      let _ = req.bytes().await?;
      return Ok(CreatePetsResponse::Created);
    }
    let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(req).await?;
    Ok(CreatePetsResponse::Unknown(data))
  }
}
///Response types for createPets
#[derive(Debug, Clone)]
pub enum CreatePetsResponse {
  ///201: Null response
  Created,
  ///default: unexpected error
  Unknown(Error),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Error {
  pub code: i32,
  pub message: String,
}
///List all cats
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ListCatsRequest {
  #[validate(nested)]
  pub query: ListCatsRequestQuery,
  pub header: ListCatsRequestHeader,
}
#[bon::bon]
impl ListCatsRequest {
  ///Create a new request with the given parameters.
  #[builder]
  pub fn new(limit: Option<i32>, x_sort_order: Option<ListCatsRequestHeaderXSortOrder>) -> anyhow::Result<Self> {
    let request = Self {
      query: ListCatsRequestQuery { limit },
      header: ListCatsRequestHeader { x_sort_order },
    };
    request.validate()?;
    Ok(request)
  }
}
impl ListCatsRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<ListCatsResponse> {
    let status = req.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<Cats>::json_with_diagnostics(req).await?;
      return Ok(ListCatsResponse::Ok(data));
    }
    let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(req).await?;
    Ok(ListCatsResponse::Unknown(data))
  }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct ListCatsRequestHeader {
  ///Sort order for the results
  pub x_sort_order: Option<ListCatsRequestHeaderXSortOrder>,
}
impl core::convert::TryFrom<&ListCatsRequestHeader> for http::HeaderMap {
  type Error = http::header::InvalidHeaderValue;
  fn try_from(headers: &ListCatsRequestHeader) -> core::result::Result<Self, Self::Error> {
    let mut map = http::HeaderMap::with_capacity(1usize);
    if let Some(value) = &headers.x_sort_order {
      let header_value = http::HeaderValue::try_from(value.to_string())?;
      map.insert(X_SORT_ORDER, header_value);
    }
    Ok(map)
  }
}
impl core::convert::TryFrom<ListCatsRequestHeader> for http::HeaderMap {
  type Error = http::header::InvalidHeaderValue;
  fn try_from(headers: ListCatsRequestHeader) -> core::result::Result<Self, Self::Error> {
    http::HeaderMap::try_from(&headers)
  }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, oas3_gen_support::Default)]
pub enum ListCatsRequestHeaderXSortOrder {
  #[serde(rename = "asc")]
  #[default]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}
impl core::fmt::Display for ListCatsRequestHeaderXSortOrder {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    match self {
      Self::Asc => write!(f, "asc"),
      Self::Desc => write!(f, "desc"),
    }
  }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct ListCatsRequestQuery {
  ///How many items to return at one time (max 100)
  #[validate(range(min = 1i32, max = 100i32))]
  pub limit: Option<i32>,
}
///Response types for listCats
#[derive(Debug, Clone)]
pub enum ListCatsResponse {
  ///200: A paged array of cats
  Ok(Cats),
  ///default: unexpected error
  Unknown(Error),
}
///List all pets
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ListPetsRequest {
  #[validate(nested)]
  pub query: ListPetsRequestQuery,
  pub header: ListPetsRequestHeader,
}
#[bon::bon]
impl ListPetsRequest {
  ///Create a new request with the given parameters.
  #[builder]
  pub fn new(
    limit: Option<i32>,
    x_sort_order: Option<ListCatsRequestHeaderXSortOrder>,
    x_only: Option<Vec<ListPetsRequestHeaderXonly>>,
  ) -> anyhow::Result<Self> {
    let request = Self {
      query: ListPetsRequestQuery { limit },
      header: ListPetsRequestHeader { x_sort_order, x_only },
    };
    request.validate()?;
    Ok(request)
  }
}
impl ListPetsRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<ListPetsResponse> {
    let status = req.status();
    if status.is_success() {
      let content_type_str = req
        .headers()
        .get(reqwest::header::CONTENT_TYPE)
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/json");
      if content_type_str.contains("json") {
        let data = oas3_gen_support::Diagnostics::<Pets>::json_with_diagnostics(req).await?;
        return Ok(ListPetsResponse::Ok(data));
      }
      if content_type_str.contains("xml") {
        let data = oas3_gen_support::Diagnostics::<Pets>::xml_with_diagnostics(req).await?;
        return Ok(ListPetsResponse::Ok(data));
      }
    }
    let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(req).await?;
    Ok(ListPetsResponse::Unknown(data))
  }
}
#[derive(Debug, Clone, PartialEq, oas3_gen_support::Default)]
pub struct ListPetsRequestHeader {
  ///Sort order for the results
  pub x_sort_order: Option<ListCatsRequestHeaderXSortOrder>,
  ///Only include pets with a tag
  pub x_only: Option<Vec<ListPetsRequestHeaderXonly>>,
}
impl core::convert::TryFrom<&ListPetsRequestHeader> for http::HeaderMap {
  type Error = http::header::InvalidHeaderValue;
  fn try_from(headers: &ListPetsRequestHeader) -> core::result::Result<Self, Self::Error> {
    let mut map = http::HeaderMap::with_capacity(2usize);
    if let Some(value) = &headers.x_sort_order {
      let header_value = http::HeaderValue::try_from(value.to_string())?;
      map.insert(X_SORT_ORDER, header_value);
    }
    if let Some(value) = &headers.x_only {
      let header_value = http::HeaderValue::try_from(
        value
          .iter()
          .map(std::string::ToString::to_string)
          .collect::<Vec<_>>()
          .join(","),
      )?;
      map.insert(X_ONLY, header_value);
    }
    Ok(map)
  }
}
impl core::convert::TryFrom<ListPetsRequestHeader> for http::HeaderMap {
  type Error = http::header::InvalidHeaderValue;
  fn try_from(headers: ListPetsRequestHeader) -> core::result::Result<Self, Self::Error> {
    http::HeaderMap::try_from(&headers)
  }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, oas3_gen_support::Default)]
pub enum ListPetsRequestHeaderXonly {
  #[serde(rename = "cat")]
  #[default]
  Cat,
  #[serde(rename = "dog")]
  Dog,
  #[serde(rename = "fish")]
  Fish,
  #[serde(rename = "bird")]
  Bird,
}
impl core::fmt::Display for ListPetsRequestHeaderXonly {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    match self {
      Self::Cat => write!(f, "cat"),
      Self::Dog => write!(f, "dog"),
      Self::Fish => write!(f, "fish"),
      Self::Bird => write!(f, "bird"),
    }
  }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct ListPetsRequestQuery {
  ///How many items to return at one time (max 100)
  #[validate(range(min = 1i32, max = 100i32))]
  pub limit: Option<i32>,
}
///Response types for listPets
#[derive(Debug, Clone)]
pub enum ListPetsResponse {
  ///200: A paged array of pets
  Ok(Pets),
  ///default: unexpected error
  Unknown(Error),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Pet {
  pub id: i64,
  pub name: String,
  pub tag: Option<String>,
}
pub type Pets = Vec<Pet>;
///Info for a specific pet
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ShowPetByIdRequest {
  #[validate(nested)]
  pub path: ShowPetByIdRequestPath,
  #[validate(nested)]
  pub header: ShowPetByIdRequestHeader,
}
#[bon::bon]
impl ShowPetByIdRequest {
  ///Create a new request with the given parameters.
  #[builder]
  pub fn new(pet_id: String, x_api_version: String) -> anyhow::Result<Self> {
    let request = Self {
      path: ShowPetByIdRequestPath { pet_id },
      header: ShowPetByIdRequestHeader { x_api_version },
    };
    request.validate()?;
    Ok(request)
  }
}
impl ShowPetByIdRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<ShowPetByIdResponse> {
    let status = req.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<Pet>::json_with_diagnostics(req).await?;
      return Ok(ShowPetByIdResponse::Ok(data));
    }
    let data = oas3_gen_support::Diagnostics::<Error>::json_with_diagnostics(req).await?;
    Ok(ShowPetByIdResponse::Unknown(data))
  }
}
#[derive(Debug, Clone, PartialEq, validator::Validate, oas3_gen_support::Default)]
pub struct ShowPetByIdRequestHeader {
  ///API version to use for this request
  #[validate(length(min = 1u64))]
  pub x_api_version: String,
}
impl core::convert::TryFrom<&ShowPetByIdRequestHeader> for http::HeaderMap {
  type Error = http::header::InvalidHeaderValue;
  fn try_from(headers: &ShowPetByIdRequestHeader) -> core::result::Result<Self, Self::Error> {
    let mut map = http::HeaderMap::with_capacity(1usize);
    let header_value = http::HeaderValue::try_from(&headers.x_api_version)?;
    map.insert(X_API_VERSION, header_value);
    Ok(map)
  }
}
impl core::convert::TryFrom<ShowPetByIdRequestHeader> for http::HeaderMap {
  type Error = http::header::InvalidHeaderValue;
  fn try_from(headers: ShowPetByIdRequestHeader) -> core::result::Result<Self, Self::Error> {
    http::HeaderMap::try_from(&headers)
  }
}
#[derive(Debug, Clone, PartialEq, validator::Validate, oas3_gen_support::Default)]
pub struct ShowPetByIdRequestPath {
  ///The id of the pet to retrieve
  #[validate(length(min = 1u64))]
  pub pet_id: String,
}
///Response types for showPetById
#[derive(Debug, Clone)]
pub enum ShowPetByIdResponse {
  ///200: Expected response to a valid request
  Ok(Pet),
  ///default: unexpected error
  Unknown(Error),
}
