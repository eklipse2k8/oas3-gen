//!
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! Union Serialization Test API
//! Source: crates/oas3-gen/fixtures/union_serde.json
//! Version: 1.0.0
//! Generated by `oas3-gen v0.23.6`
//!
//! Comprehensive test fixture for union serialization/deserialization

use serde::{Deserialize, Serialize};
///Text annotation with different types
#[derive(Debug, Clone, PartialEq)]
pub enum Annotation {
  Citation(CitationAnnotation),
  Link(LinkAnnotation),
}
impl Annotation {
  pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for Annotation {
  fn default() -> Self {
    Self::Citation(<CitationAnnotation>::default())
  }
}
impl serde::Serialize for Annotation {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: serde::Serializer,
  {
    match self {
      Self::Citation(v) => v.serialize(serializer),
      Self::Link(v) => v.serialize(serializer),
    }
  }
}
impl<'de> serde::Deserialize<'de> for Annotation {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
    let value = serde_json::Value::deserialize(deserializer)?;
    match value.get(Self::DISCRIMINATOR_FIELD).and_then(|v| v.as_str()) {
      Some("citation") => serde_json::from_value(value)
        .map(Self::Citation)
        .map_err(serde::de::Error::custom),
      Some("link") => serde_json::from_value(value)
        .map(Self::Link)
        .map_err(serde::de::Error::custom),
      None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
      Some(other) => Err(serde::de::Error::custom(format!(
        "Unknown discriminator value '{}' for field '{}'",
        other, "type"
      ))),
    }
  }
}
///Test union that can be single item or array
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum ArrayOrSingle {
  #[default]
  TextBlock(TextBlock),
  Array(Vec<TextBlock>),
}
impl ArrayOrSingle {
  pub fn text_block(text: String) -> Self {
    Self::TextBlock(TextBlock {
      text,
      ..Default::default()
    })
  }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct Base64ImageSource {
  pub data: Vec<u8>,
  pub media_type: MediaType,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("base64".to_string()))]
  pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct CitationAnnotation {
  pub end: i64,
  #[validate(length(min = 1u64))]
  pub source: String,
  pub start: i64,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("citation".to_string()))]
  pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct CodeBlock {
  #[validate(length(min = 1u64))]
  pub code: String,
  pub language: Option<String>,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("code".to_string()))]
  pub r#type: Option<String>,
}
///A union of content block types with discriminator
#[derive(Debug, Clone, PartialEq)]
pub enum ContentBlock {
  Code(CodeBlock),
  Image(ImageBlock),
  Text(TextBlock),
  ToolResult(ToolResultBlock),
  ToolUse(ToolUseBlock),
}
impl ContentBlock {
  pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for ContentBlock {
  fn default() -> Self {
    Self::Code(<CodeBlock>::default())
  }
}
impl serde::Serialize for ContentBlock {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: serde::Serializer,
  {
    match self {
      Self::Code(v) => v.serialize(serializer),
      Self::Image(v) => v.serialize(serializer),
      Self::Text(v) => v.serialize(serializer),
      Self::ToolResult(v) => v.serialize(serializer),
      Self::ToolUse(v) => v.serialize(serializer),
    }
  }
}
impl<'de> serde::Deserialize<'de> for ContentBlock {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
    let value = serde_json::Value::deserialize(deserializer)?;
    match value.get(Self::DISCRIMINATOR_FIELD).and_then(|v| v.as_str()) {
      Some("code") => serde_json::from_value(value)
        .map(Self::Code)
        .map_err(serde::de::Error::custom),
      Some("image") => serde_json::from_value(value)
        .map(Self::Image)
        .map_err(serde::de::Error::custom),
      Some("text") => serde_json::from_value(value)
        .map(Self::Text)
        .map_err(serde::de::Error::custom),
      Some("tool_result") => serde_json::from_value(value)
        .map(Self::ToolResult)
        .map_err(serde::de::Error::custom),
      Some("tool_use") => serde_json::from_value(value)
        .map(Self::ToolUse)
        .map_err(serde::de::Error::custom),
      None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
      Some(other) => Err(serde::de::Error::custom(format!(
        "Unknown discriminator value '{}' for field '{}'",
        other, "type"
      ))),
    }
  }
}
impl ContentBlock {
  pub fn text(text: String) -> Self {
    Self::Text(TextBlock {
      text,
      ..Default::default()
    })
  }
  pub fn image(source: Box<ImageSource>) -> Self {
    Self::Image(ImageBlock {
      source,
      ..Default::default()
    })
  }
  pub fn code(code: String) -> Self {
    Self::Code(CodeBlock {
      code,
      ..Default::default()
    })
  }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct ContentBlockDeltaEvent {
  ///Delta content for streaming
  pub delta: Box<Delta>,
  pub index: i64,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("content_block_delta".to_string()))]
  pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct ContentBlockStartEvent {
  ///A union of content block types with discriminator
  pub content_block: Box<ContentBlock>,
  pub index: i64,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("content_block_start".to_string()))]
  pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct ContentBlockStopEvent {
  pub index: i64,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("content_block_stop".to_string()))]
  pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
pub struct ContentRequest {
  pub blocks: Vec<ContentBlock>,
  ///Flexible metadata that can be string or object
  pub metadata: Option<Metadata>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ContentResponse {
  ///A union of content block types with discriminator
  pub content: Box<ContentBlock>,
  pub id: String,
  pub usage: Option<Usage>,
}
///Delta content for streaming
#[derive(Debug, Clone, PartialEq)]
pub enum Delta {
  InputJson(InputJsonDelta),
  Text(TextDelta),
}
impl Delta {
  pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for Delta {
  fn default() -> Self {
    Self::InputJson(<InputJsonDelta>::default())
  }
}
impl<'de> serde::Deserialize<'de> for Delta {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
    let value = serde_json::Value::deserialize(deserializer)?;
    match value.get(Self::DISCRIMINATOR_FIELD).and_then(|v| v.as_str()) {
      Some("input_json_delta") => serde_json::from_value(value)
        .map(Self::InputJson)
        .map_err(serde::de::Error::custom),
      Some("text_delta") => serde_json::from_value(value)
        .map(Self::Text)
        .map_err(serde::de::Error::custom),
      None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
      Some(other) => Err(serde::de::Error::custom(format!(
        "Unknown discriminator value '{}' for field '{}'",
        other, "type"
      ))),
    }
  }
}
impl Delta {
  pub fn text(text: String) -> Self {
    Self::Text(TextDelta {
      text,
      ..Default::default()
    })
  }
  pub fn input_json(partial_json: String) -> Self {
    Self::InputJson(InputJsonDelta {
      partial_json,
      ..Default::default()
    })
  }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ErrorDetails {
  pub message: String,
  #[serde(rename = "type")]
  pub r#type: ErrorType,
}
impl std::fmt::Display for ErrorDetails {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "{}", self.message)
  }
}
impl std::error::Error for ErrorDetails {}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct ErrorResponse {
  pub error: ErrorDetails,
  #[serde(rename = "type")]
  #[default("error".to_string())]
  pub r#type: String,
}
impl std::fmt::Display for ErrorResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "{}", self.error)
  }
}
impl std::error::Error for ErrorResponse {
  fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
    Some(&self.error as &(dyn std::error::Error + 'static))
  }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Deserialize, oas3_gen_support::Default)]
pub enum ErrorType {
  #[serde(rename = "invalid_request_error")]
  #[default]
  InvalidRequestError,
  #[serde(rename = "authentication_error")]
  AuthenticationError,
  #[serde(rename = "permission_error")]
  PermissionError,
  #[serde(rename = "not_found_error")]
  NotFoundError,
  #[serde(rename = "rate_limit_error")]
  RateLimitError,
  #[serde(rename = "api_error")]
  ApiError,
  #[serde(rename = "overloaded_error")]
  OverloadedError,
}
///Streaming event with different types
#[derive(Debug, Clone, PartialEq)]
pub enum Event {
  ContentBlockDelta(ContentBlockDeltaEvent),
  ContentBlockStart(ContentBlockStartEvent),
  ContentBlockStop(ContentBlockStopEvent),
  MessageStart(MessageStartEvent),
  MessageStop(MessageStopEvent),
  Ping(PingEvent),
}
impl Event {
  pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for Event {
  fn default() -> Self {
    Self::ContentBlockDelta(<ContentBlockDeltaEvent>::default())
  }
}
impl<'de> serde::Deserialize<'de> for Event {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
    let value = serde_json::Value::deserialize(deserializer)?;
    match value.get(Self::DISCRIMINATOR_FIELD).and_then(|v| v.as_str()) {
      Some("content_block_delta") => serde_json::from_value(value)
        .map(Self::ContentBlockDelta)
        .map_err(serde::de::Error::custom),
      Some("content_block_start") => serde_json::from_value(value)
        .map(Self::ContentBlockStart)
        .map_err(serde::de::Error::custom),
      Some("content_block_stop") => serde_json::from_value(value)
        .map(Self::ContentBlockStop)
        .map_err(serde::de::Error::custom),
      Some("message_start") => serde_json::from_value(value)
        .map(Self::MessageStart)
        .map_err(serde::de::Error::custom),
      Some("message_stop") => serde_json::from_value(value)
        .map(Self::MessageStop)
        .map_err(serde::de::Error::custom),
      Some("ping") => serde_json::from_value(value)
        .map(Self::Ping)
        .map_err(serde::de::Error::custom),
      None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
      Some(other) => Err(serde::de::Error::custom(format!(
        "Unknown discriminator value '{}' for field '{}'",
        other, "type"
      ))),
    }
  }
}
impl Event {
  pub fn message_start(message: Message) -> Self {
    Self::MessageStart(MessageStartEvent {
      message,
      ..Default::default()
    })
  }
  pub fn content_block_stop(index: i64) -> Self {
    Self::ContentBlockStop(ContentBlockStopEvent {
      index,
      ..Default::default()
    })
  }
  pub fn message_stop() -> Self {
    Self::MessageStop(MessageStopEvent::default())
  }
  pub fn ping() -> Self {
    Self::Ping(PingEvent::default())
  }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct EventList {
  pub events: Vec<Event>,
}
///Get events with discriminated union
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetEventsRequest {}
impl GetEventsRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<GetEventsResponse> {
    let status = req.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<EventList>::json_with_diagnostics(req).await?;
      return Ok(GetEventsResponse::Ok(data));
    }
    let _ = req.bytes().await?;
    Ok(GetEventsResponse::Unknown)
  }
}
///Response types for getEvents
#[derive(Debug, Clone)]
pub enum GetEventsResponse {
  ///200: Event stream
  Ok(EventList),
  ///default: Unknown response
  Unknown,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct ImageBlock {
  pub alt_text: Option<String>,
  ///Image source can be base64 or URL
  pub source: Box<ImageSource>,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("image".to_string()))]
  pub r#type: Option<String>,
}
///Image source can be base64 or URL
#[derive(Debug, Clone, PartialEq)]
pub enum ImageSource {
  Base64(Base64ImageSource),
  Url(UrlImageSource),
}
impl ImageSource {
  pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for ImageSource {
  fn default() -> Self {
    Self::Base64(<Base64ImageSource>::default())
  }
}
impl serde::Serialize for ImageSource {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: serde::Serializer,
  {
    match self {
      Self::Base64(v) => v.serialize(serializer),
      Self::Url(v) => v.serialize(serializer),
    }
  }
}
impl<'de> serde::Deserialize<'de> for ImageSource {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
    let value = serde_json::Value::deserialize(deserializer)?;
    match value.get(Self::DISCRIMINATOR_FIELD).and_then(|v| v.as_str()) {
      Some("base64") => serde_json::from_value(value)
        .map(Self::Base64)
        .map_err(serde::de::Error::custom),
      Some("url") => serde_json::from_value(value)
        .map(Self::Url)
        .map_err(serde::de::Error::custom),
      None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
      Some(other) => Err(serde::de::Error::custom(format!(
        "Unknown discriminator value '{}' for field '{}'",
        other, "type"
      ))),
    }
  }
}
impl ImageSource {
  pub fn url(url: String) -> Self {
    Self::Url(UrlImageSource {
      url,
      ..Default::default()
    })
  }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct InputJsonDelta {
  pub partial_json: String,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("input_json_delta".to_string()))]
  pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct LinkAnnotation {
  pub end: i64,
  pub start: i64,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("link".to_string()))]
  pub r#type: Option<String>,
  #[validate(url, length(min = 1u64))]
  pub url: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum MediaType {
  #[serde(rename = "image/jpeg")]
  #[default]
  ImageJpeg,
  #[serde(rename = "image/png")]
  ImagePng,
  #[serde(rename = "image/gif")]
  ImageGif,
  #[serde(rename = "image/webp")]
  ImageWebp,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Message {
  pub content: Vec<ContentBlock>,
  pub id: String,
  pub model: String,
  pub role: Role,
  pub stop_reason: Option<StopReason>,
  pub usage: Option<Usage>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct MessageStartEvent {
  pub message: Message,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("message_start".to_string()))]
  pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct MessageStopEvent {
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("message_stop".to_string()))]
  pub r#type: Option<String>,
}
///Flexible metadata that can be string or object
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum Metadata {
  #[default]
  String(String),
  Object(std::collections::HashMap<String, serde_json::Value>),
}
///Test nullable union with primitives
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum NullableStringOrNumber {
  #[default]
  String(String),
  Number(f64),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct PingEvent {
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("ping".to_string()))]
  pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Deserialize, oas3_gen_support::Default)]
pub enum Role {
  #[serde(rename = "user")]
  #[default]
  User,
  #[serde(rename = "assistant")]
  Assistant,
}
///Send content blocks
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct SendContentRequest {
  pub body: ContentRequest,
}
impl SendContentRequest {
  ///Parse the HTTP response into the response enum.
  pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<SendContentResponse> {
    let status = req.status();
    if status.is_success() {
      let data = oas3_gen_support::Diagnostics::<ContentResponse>::json_with_diagnostics(req).await?;
      return Ok(SendContentResponse::Ok(data));
    }
    if status.as_u16() == 400u16 {
      let data = oas3_gen_support::Diagnostics::<ErrorResponse>::json_with_diagnostics(req).await?;
      return Ok(SendContentResponse::BadRequest(data));
    }
    let _ = req.bytes().await?;
    Ok(SendContentResponse::Unknown)
  }
}
///Response types for sendContent
#[derive(Debug, Clone)]
pub enum SendContentResponse {
  ///200: Success
  Ok(ContentResponse),
  ///400: Bad request
  BadRequest(ErrorResponse),
  ///default: Unknown response
  Unknown,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Deserialize, oas3_gen_support::Default)]
pub enum StopReason {
  #[serde(rename = "end_turn")]
  #[default]
  EndTurn,
  #[serde(rename = "max_tokens")]
  MaxTokens,
  #[serde(rename = "stop_sequence")]
  StopSequence,
  #[serde(rename = "tool_use")]
  ToolUse,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct TextBlock {
  pub annotations: Option<Vec<Annotation>>,
  #[validate(length(min = 1u64))]
  pub text: String,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("text".to_string()))]
  pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct TextDelta {
  pub text: String,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("text_delta".to_string()))]
  pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct ToolResultBlock {
  ///Tool result can be text or array of content blocks
  pub content: ToolResultContent,
  pub is_error: Option<bool>,
  #[validate(length(min = 1u64))]
  pub tool_use_id: String,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("tool_result".to_string()))]
  pub r#type: Option<String>,
}
///Tool result can be text or array of content blocks
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum ToolResultContent {
  #[default]
  String(String),
  Array(Vec<ToolResultContentBlock>),
}
#[derive(Debug, Clone, PartialEq)]
pub enum ToolResultContentBlock {
  Image(ImageBlock),
  Text(TextBlock),
}
impl ToolResultContentBlock {
  pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for ToolResultContentBlock {
  fn default() -> Self {
    Self::Image(<ImageBlock>::default())
  }
}
impl serde::Serialize for ToolResultContentBlock {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: serde::Serializer,
  {
    match self {
      Self::Image(v) => v.serialize(serializer),
      Self::Text(v) => v.serialize(serializer),
    }
  }
}
impl<'de> serde::Deserialize<'de> for ToolResultContentBlock {
  fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  where
    D: serde::Deserializer<'de>,
  {
    let value = serde_json::Value::deserialize(deserializer)?;
    match value.get(Self::DISCRIMINATOR_FIELD).and_then(|v| v.as_str()) {
      Some("image") => serde_json::from_value(value)
        .map(Self::Image)
        .map_err(serde::de::Error::custom),
      Some("text") => serde_json::from_value(value)
        .map(Self::Text)
        .map_err(serde::de::Error::custom),
      None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
      Some(other) => Err(serde::de::Error::custom(format!(
        "Unknown discriminator value '{}' for field '{}'",
        other, "type"
      ))),
    }
  }
}
impl ToolResultContentBlock {
  pub fn text(text: String) -> Self {
    Self::Text(TextBlock {
      text,
      ..Default::default()
    })
  }
  pub fn image(source: Box<ImageSource>) -> Self {
    Self::Image(ImageBlock {
      source,
      ..Default::default()
    })
  }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct ToolUseBlock {
  #[validate(length(min = 1u64))]
  pub id: String,
  pub input: std::collections::HashMap<String, serde_json::Value>,
  #[validate(length(min = 1u64))]
  pub name: String,
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("tool_use".to_string()))]
  pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct UrlImageSource {
  #[doc(hidden)]
  #[serde(rename = "type", skip_deserializing, default)]
  #[default(Some("url".to_string()))]
  pub r#type: Option<String>,
  #[validate(url, length(min = 1u64))]
  pub url: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct Usage {
  pub input_tokens: i64,
  pub output_tokens: i64,
}
